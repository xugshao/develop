┏━━━━━━━━━━━━━━━━━━┓
┃　第一部分：ActionScript 3 语言基础 ┃
┗━━━━━━━━━━━━━━━━━━┛
================================================
第2章 ActionScript 3 语言基本元素
================================================
2.1.2 数据类型概述
简单数据类型
Boolean(布尔)、int(有符整型)、Number(浮点)、String(字符串)、uint(无符整型)
复杂数据类型
Array(数组)、Date(日期)、Error(异常)、Function(函数)、RegExp(正则表达)、XML、XMLList


2.2.1 变量声明
var 变量：类型
var 变量：类型 = 值;

2.3 声明常量
const 常量名：类型 = 值；

2.4 基础数据类型
1.布尔值 Boolean(初始化为false)
2.数字:int uint Number
int  有符号32位整数 -2(31次方) -  +(2(31次方)-1)
uint 无符号32位整数 0 -  2(32次方)-1
Number 64位浮点

能用整数优先用int uint，有正负之分，用int。只处理整数，用uint，有小数，用Number。


2.4.6 Object及关联数组
var 对象:Object = new Object()
var 对象:Object = {};


2.4.8
Null、NaN、undefined及各自应用对象：变量的默认值
数据类型        默认值
int             0
uint            0
Number          NaN
String          null
Boolean         false
Array           null
Object          null
没声明          undefined
*               undefined

注意:必须声明初值,否则容易出错。

2.5 运算符，表达式及运用

2.5.11 typeof、is、as
typeof，用字符串返回对象类型，格式： typeof(对象)
is    ，判断操作符左边的对象是否属于右边的类型，返回值为Boolean，格式：  对象 is 数据类型
as    ，判断操作符左边的对象是否属于右边的类型，属于则返回数据，不属于则返回null，格式： 对象 as 数据类型

typeof对象类型与返回结果对照表
对象类型                返回结果
Array                   object
Boolean                 boolean
Function                function
int                     number
Number                  number
Object                  object
String                  string
uint                    number
XML                     xml
XMLList                 xml



2.5.12 in
in    ，判断操作符左边的对象是否作为右边对象中的键(Key)或索引，返回值为Boolean
比如：
var a:Array = ["q","w","e"];
trace(2 in a);  //数组中有索引2，返回true
trace(3 in a);  //数组中没有索引3，返回false

2.5.13 delete关键字
AS2.0中可以删除任意任意对象的delete关键字，在AS3.0中只能用于删除对象的动态实例属性，非动态属性不能删除。

如果要将一个对象删除，使用 对象名 = null 来进行赋值操作即可。




================================================
第3章 ActionScript 3 流程控制
================================================
3.4.5 for...in和for each...in
for(var 枚举变量 in 枚举集合)  //枚举变量返回为集合元素键名
for each(var 枚举变量 in 枚举集合)  //枚举变量返回为集合元素值

3.4.7 break和continue标签的特殊用法
在循环语句前用  标签:  的形式为循环体赋标签，然后就可以在break和continue语句后 加上空格+这个标签，实现控制对应循环的功能。

3.5 AS3.0中switch比较默认使用 === 全等比较，switch条件不会自动执行类型转换，要注意。




================================================
第4章 ActionScript 3 中的函数及高级使用技巧
================================================
4.1.1 两种定义函数的方法
函数定义式      -       函数变量式
函数语句定义法  -       函数表达式定义法
函数定义式 用function开头，function 函数名(){}
函数变量式 用 var 变量名 = function(){} ，即匿名函数

AS编译器会优先执行定义式的函数,而变量式函数则只能先定义，后使用(与变量一样，先定义，后使用)

变量式中this关键字绑定对象 定义式中this关键字只绑定场景
var num:int = 3;
function testThisA(){
        trace(this.num)
        //此处输出3
}
var testThisB:Function = function(){
        trace(this.num)
        //此处输出300
}

var Obj:Object = {num:300};
Obj.TestA = testThisA
Obj.TestB = testThisB


4.2 参数
4.2.1 按引用传入参数
AS3.0中，所有形参均为引用传入方式，只不过，基元数据是不变对象，所以与传值方式效果一样。

4.2.2 函数默认参数
function 函数名(形参:类型 = 默认值)

4.2.3 形式参数数组
函数中默认自动生成的arguments对象中保存有所有定义中的形参参数

AS2.0中的arguments数组形参对象，存放所有传入的不定个数的形参参数。
而在AS3.0中，argument则被严格限定存放形参定义中所定义个数的形参。
arguments对象有一个length属性和一个callee方法。

function 函数名(形参:数据类型,形参:数据类型){
        trace(arguments.length)
        arguments.callee
        //调用函数本体，一般用于创建递归
}


如果需要传入任意多个参数，则使用AS3.0中的rest关键字，即 ...
特殊关键字 ...(rest)

function 函数名(...参数名){
        //参数名可随意定义
        trace(参数名.length)
}

最后要注意的，arguments与...rest关键字不能混用，使用了...rest则arguments则不能再使用



┏━━━━━━━━━━━━━━━━━━━━┓
┃　第二部分：ActionScript 3 面向对象编程 ┃
┗━━━━━━━━━━━━━━━━━━━━┛
================================================
第5章 类和对象 ━━ 从定义到原理
================================================
5.1 基本类结构

基本结构：HelloWorld
package
{
public class Hello
{
        public var helloString:String = 'World';
        public function Hello(){
        }
        public function sayHello():void{
                trace("Hello");
        }
}
}


ActionScript3中的类如果想被外部访问，必须放在package(包)中
构造函数与类名相同，为与其它类内函数区分，一般首字母大写。



5.2 Class(类)和Object(对象)
类是对象结构的描述。

5.3 Class的成员
ActionScript3中的Class(类)的构成
・Class的名称和包路径
・构造函数
・属性：包括实例属性和表态静态属性
・方法：包括实例方法和静态方法

AS3中对类的默认访问控制是internal(包内可见)，而非AS2.0中的public



5.4 Class和object的创建和使用
5.4.1 创建Class
参看5.1 基本类结构


5.4.2 创建类的实例
import 包路径.类名
///////////////////////////////////////////////////////////相同包下，不用import类名，可直接引用

var 对象 = new 类()
var 对象:类 = new 类() //推荐

new 关键字后跟的其实不是类名，而是类的构造函数



5.5 Class和package(包)
package格式:
package 项目根.包路径
比如：
package com.kinda.book.display

类名统一用大写字母开头，包路径统一用小写


类体结构安排：
package [包名]{
        import 类包;
        public class 类
        {
                //private 静态属性
                //private 静态方法
                //private 实例属性
                //构造函数
                //实例方法
                //静属 静方 实属 构函 实方，声明类内数据的五个顺序
                public function 构造函数(){
                        //函数代码      
                }
        }

}



5.6 实例属性和实例方法
实例属性和实例方法类似于动态网页语言中的session，不同的类实例(对象)中的实例属性可以有不同值 。
5.6.1 实例属性
访问控制符 var 属性名:数据类型;
访问控制符 var 属性名:数据类型 = 值;

访问控制符可以是 internal public private protect 或者自定义的namespace标识

默认为internal - 包内成员可以访问，包外不可访问


5.6.2 实例方法
访问控制符 function 方法名(形参):返回值类型{
        //方法内容  
}


5.6.3 访问实例属性和实例方法
使用new 语法实例化对象后，
对象.属性|方法名



5.7 静态属性和静态方法
静态属性和静态方法类似于动态网页语言中的Application，不同的类实例(对象)间共享类中共同的属性和方法。

声明静态属性：
static var 属性:数据类型;
static var 属性:数据类型 = 值;
public static var 属性:数据类型;
public static var 属性:数据类型 = 值;

不加访问控制符时，默认同样是internal

如果要声明静态常量，需要配合使用 static 和 const

static const 属性:数据类型 = 值;


静态方法:
同样是使用static关键字
访问控制符 static function 方法名(形参):返回值类型{
        //方法内容
}


5.7.3 访问静态属性和静态方法
类名.属性
类名.方法
例：
Math.floor
Math.PI

为了避免与类内成员变量冲突，访问静态属性及方法时，即使在类体内访问也最好用 类名.属性 这样的格式来写


5.7.4 应用1：使用静态属性集中管理数据
public static const PI:Number = 3.141592653589793;
比如事件定义，一般都是使用静态属性的，那我们使用中文来定义属性，就可以在代码中使用中文事件了
比如：
public static const 播放:String = "play";

使用事件时就可以用 对象.播放 来实现代码的中文化了


5.7.5 应用2：使用静态属性部分实现Enumeration(枚举) [略]

5.7.6 应用3：实现工具类
如：Math String等类



5.8 构造函数
定义：构造函数用于创建对象时供系统自动调用的函数，实现数据的初始化操作
格式：
public 类名(形参){
        //构造函数名与类名相同，首字母大写，以与其它函数等区分
        //形参中同样可以使用...rest运算符载入不同个数的参数，实现类似重载的功能
}


5.8.3 构造函数的返回类型
构造函数只能返回undefined值，所以return没意义。
但return可以影响构造函数向下执行代码的顺序，遇到return时，其下的代码将终止执行。



5.9 Clas的种类：动态类和密封类
密封类在运行时不能动态添加属性或方法。
动态类在运行时可以动态添加属性或方法。
默认声明的类为静态类，动态类在class关键字前有 dynamic 关键字

注意：AS3.0中的 for...in循环， for each...in循环只能遍历动态类对象的动态属性



5.10 this关键字 [略]

5.11 ActionScript3中的方法重载
public 类名(...rest){
        //根据传入的函数个数进行处理
        //不支持不同类型参数的区分作为重载的标准

}

5.12 含有多个类的ActionScript3 类文件的标准例子
(1)每个AS3的Class都必须写个一个和类同句的.as文件中
(2)package包体括号内只能定义一个Class
(3)在package包体中定义的Class，必须与类文件名相同
(4)在package包体括号外还可以定义其它类，这种类，叫包外类，只能被当前as文件中的成员类访问




========================================================
第6章 ActionScript3中的封装：类的成员、类、包与访问控制
========================================================
公认OOP的三大要素为：封装、继承、多态

6.1 什么是封装 [概括]
封装(encapsulation)，又叫隐藏实现(hiding the implementation)，具体的意思是将实现的细节隐藏起来，只将必要的功能接口对外公开。打个比喻就是汽车，用户只需要知道踏油门就会加油，打方向盘就会转向，至于汽车内部的实现细节，用户不用知道，而这些细节，就是属于封装了。

在ActionScript3.0中，使用 访问控制说明符 来控制代码的可见度。
访问控制说明符从“毫无限制”到“严格限制”的顺序是：
public          完全公开
protected       在private的基础上，允许子类访问
internal        包内可见
private         类内可见

┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃　                                 引用原话:                                    ┃
┃                                                                                ┃
┃     一个好的OOP程序，就像人开汽车那样，对象和对象之间的交流只限于公开的接口。  ┃
┃  好的OOP程序，没有流程执行先后的概念，只有代码单元之间如何相互交流和协同工作   ┃
┃  的模式。这些代码单元，又被称为模块。模块在代码中的表现形式是一个单独的类或    ┃
┃  多个类。这些类共同协作，提供一种或多种服务。    那么如何让一部分接口暴露呢？  ┃
┃  如何隐藏不对外公开的方法呢？使用访问控制说明符，这是实现封装的一个重要方法。  ┃
┃  ActionScript3使用访问控制说明符来告知外部使用者，本代码单元有哪些成员可以被   ┃
┃  外部访问到，哪些不能被访问到。将访问控制符从“毫无限制”到“严格限制”        ┃
┃  排一下序：public、protected、internal和private。这些访问控制符，清楚明白地    ┃
┃  描述了每个部分的访问权限。一个优秀的OOP程序，会尽可能将单个代码单元的细节隐   ┃
┃  藏起来。换句话说，就是尽可能不要对外公开代码单元的成员。顺便说一句，不少OOP   ┃
┃  程序员最喜爱private关键字，因为这意味着最大的修改自由。很有意思，在OOP编程中，┃
┃  你对代码单元访问控制得越严格，日后你对代码修改的自由越大。                    ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

6.2 为什么需要封装
6.2.1 封装使修改代码更加容易和安全
封装使程序员在后期修改代码或在应用第三方代码的时候，可以在前期严格的访问控制定义下，令到改代码的时候，可以有的放矢地改，而不用担心因为改变部分代码而有可能令到程序的其它部分产生其它新问题.

┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃　                         引用原话:                                            ┃
┃                                                                                ┃
┃    封装使修改代码更加容易和安全.开发RIA软件，和所有其它语言开发软件一样，      ┃
┃会经常调度和修改代码.一般说来，软件的修改和调度时间可能会与开发时间相等，       ┃
┃甚至更长.因此，程序开发者所写的代码要经得起不断的修改.尤其是当编写的代码要      ┃
┃提供给第三方使用时，更要小心你所做的修改，确保你的修改不会危害其它代码的稳健性. ┃
┃                                                                                ┃
┃    如何确保稳定性?每个类有那么多的属性、方法，你如何知道其它程序员使用了哪些   ┃
┃成员不知道就无从修改！如果有个标识，标识哪些是第三方可以访问的，哪些是他们不能  ┃
┃访问和修改的就好了。                                                            ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

6.2.2 封装让代码分成一个个相对独立的单元
只要保持对外的接口不变，那么内部的代码结构可以任意改动，保证了代码单元的修改和替换更加安全，软件维护和修改都能有的放矢。


6.2.3 封装让整个软件开发的复杂度大大降低
模块化，降低复杂度才是封装这个思想产生的最真实的原因，代码易于修改、替换、复用等只是这一点附带的好处而已。


6.3 ActionScript3中封装的几个层次
包外 ->  包 -> 类 -> 包外类  (由外层到内层的结构，越靠近内近，访问权限越严格)

包外：相当于公共权限，任意第三方都可以访问到其中的代码单元。

包(package)：包内的成员互相可以访问，但包内的成员不能被包外的成员访问到。

类(class)：一个包中可以包含很多个类，在类的内部，类的成员可以相互访问，但外部是没有办法访问到类的私有成员的。

包外类：这是最底层的类，在package语句外定义，只能被当前类中的成员访问，类似只能被当前类调用的私有函数。



6.4 package(包)
package用于划分访问控制和实现模块化功能。

6.4.1 包的导入(import)
使用任何一个类之前，必须先导入这个类所在的包，即使使用 全饰路径，也必须先导入包。

在Flash CS3文档时间轴上写代码时，flash.*默认是自动导入的，可不用手动import

1.导入单个类
import 包路径;

2.使用通配符导入整个包
使用*号可以快速导入指定包的所有类，但一般为了程序的清晰，建议少用，而是直接写清楚导入类的包名
import 包路径.*;

3.使用同一个包内的类文件无须导入

如果导入的不同包中有同名的类，则需要在声明使用时使用全饰路径，即：new 完整包路径.类名();


6.4.3 package的创建和命名
业界习惯是使用域名来定义包路径
比如 com.kinda.book.display

如果没有，也可以使用自己的电子邮箱
比如  com.21cn.kinda.book.display

在项目工程目录下 建立 com文件夹，在com文件夹建kinda文件夹，在kinda文件夹内建book文件夹
使用系统目录形式来实现包的管理

创建包的过程：
1.选好包名，一般以域名段倒写为前缀;
2.在硬盘上根据定好的包名结构创建对应的目录结构
3.在包中创建的任何类，头部package定义中必须写上包路径

修改包结构的时候有三点要做：
1.移动包目录
2.修改包中类头部 package中的包名
3.修改相应import类中的包名



6.5.1 类路径
Ctrl+U > ActionScript > ActionScript 3 Settings...
在此可添加系统类包路径，供全局调用。


6.6 类成员的访问控制
AS3中有四种访问控制符：
public
private
internal
protected

访问控制符不仅控制实例属性和方法，对静态属性和方法也有同样的作用。

6.6.1 internal:包内访问
AS3中所有类成员在没加访问控制符的情况下，都为默认的internal权限，
可以被同一个包内的其它类成员访问

6.6.2 public:完全公开
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃　                               引用原话:                                        ┃
┃                                                                                  ┃
┃    在些要提醒的是，public的类成员应当看成是这个类对外部做出的承诺、协议，        ┃
┃一旦决定，日后不能轻易改动。不能仅仅为了其他类可以访问某个成员，而轻率地将该成员设┃
┃为public。这是OOP新手极容易犯的错误。                                             ┃
┃    一旦发现某个类成员需要频繁被外部访问，就要先考虑这个类成员的设计是否不当，    ┃
┃可否独立出来；再考虑可否归入那些需要频繁访问的包中，使用internal级别来实现；最后再┃
┃考虑使用public的访问控制。                                                        ┃
┃      总之，尽量将类成员的访问权限控制到最低限度，这才能给日后的修改、维护代码带来┃
┃最大的自由。                                                                      ┃
┃                                                                                  ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛


6.6.3 private:仅当前类可访问
private修饰的类的成员，称为私有成员(private member),除了类体内可以访问外，包内的其它类和继承的子类等都不能访问私有成员。

对于复杂数据类型(比如数组等)的属性来说，private只能限制通过当前类的实例来访问，但不能限制这个属性所指向的引用对象本身的访问。


6.6.4 protected:子类可访问
protected修饰的对象只能被当前类和当前类的子类对象访问，等同在private基础上增加对子类的支持。

protected修饰的子类不受包的限制，可以在不同类中，如果不是当前类子类，那和private是一样的。


6.7 getter和setter方法
getter和setter方法是存取器方法
getter方法:
访问控制符 function get 访问属性名():返回类型{
        其它代码
        return 要访问的私有属性;
}

setter方法:
访问控制符 function get 访问属性名():返回类型{
        其它代码
        要访问的私有属性 = 参数;
}

概括：封装的意义就是不想用户直接访问类内的数据，而使用getter和setter则是一种折衷的办法，当用户需要设置对象属性的时候，通过setter函数对传入数据进行验证，然后再赋值给对象，确保了数据的完整性。
另外一个，当设置了setter和getter时，属性为可写可读，当只设置setter时为只写(一般较少见)，当只设置getter时，属性为只读，通过setter和getter来达到控制访问的目的。



6.8 类(Class)的访问控制
internal(包内可见)和public(包外可见)两种


6.9 包外类
包外类是类的私有单元，在package代码体外定义。
调用时，如果包中有同名类，则优先调用包外类。






========================================================
第7章 命名空间
========================================================

========================================================
第8章 复合与继承
========================================================
复合和继续的核心思想是重用现有的代码。
















┏━━━━━━━━━━━━━━━━━━┓
┃　第三部分：ActionScript 3 核心类   ┃
┗━━━━━━━━━━━━━━━━━━┛
================================================
第11章 ActionScript 3 核心类和全局函数
================================================

11.1 ActionScript3 中核心类和函数的变化及原因
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃　                                        引用原话:                                                     ┃
┃                                                                                                        ┃
┃   核心类和全局函数是什么？简单地说，就是处于顶级包中的类和函数。从代码编写上说，我们可以在任何地方直   ┃
┃接调用它们，而不需要导入包或写全饰名称。从功能上说，它们是一门编程语言中最基础的类和函数，也是最常用到  ┃
┃的功能；从包路径上说，它们处于顶层，在顶级包 （Top-Level Package）中。                                  ┃
┃                                                                                                        ┃
┃    在ActionScript3中，顶级包已经发生了很大的变动。ActionScript2中我们熟悉的很多全局函数和类，在        ┃
┃ActionScript3中都不再是顶级包中的成员了。比如，getTimer()、setInterval()函数就不再是全局函数，而        ┃
┃MovieClip类、Sound类也已经不再是顶级类。在ActionScript3中，在使用它们之前，必须使用import导入它们所在   ┃
┃的包。                                                                                                  ┃
┃   ActionScript3的核心类有多少？ActionScript2中可以全局访问的类有40多个，全局函数（包括未公开的）有70   ┃
┃个左右；相比之下，ActionScript3处于顶级的核心类只有28个，全局函数仅21个，另加全局常量4个。              ┃
┃   那么为什么会发生这么大的变化呢？                                                                     ┃
┃                                                                                                        ┃     ┃                                                                                                        ┃     ┃                                                                                                        ┃
┃ActionScript 3 中核心类和函数的变化及原因                                                               ┃
┃                                                                                                        ┃
┃    和ActionScript2 中混乱的核心类和全局函数进行比较，就可以明白ActionScript3中不得不进行变革的原因。   ┃
┃   ActionScript2拥有过多的核心类和全局函数，是非常混乱和不成熟的。先说说ActionScript2中类的架构：属于   ┃
┃显示对象的MovieClip、Video、TextField、Button，属于网络API方面的LoadVars、NetConnection、NetStream，属  ┃
┃于绘图方面的一些类，等等，还有一些其他杂七杂八的类都被放在顶级包中。再看看整个系统架构，这些顶级类和相  ┃
┃当一部分非顶级类都是直接继承自根类Object类的。在ActionScript2中，顶级包和flash.*包中总共才69个类，居然  ┃
┃有近三分之一直接放在了顶级包中，近三分之二直接继承根类Object。这样的系统架构是极不优雅的，不利于语言的  ┃
┃进一步完善。                                                                                            ┃
┃   再看全局函数中的不合理之处：getURL()、setInterval()、gotoAndStop()等不应该成为全局函数，而应当分别   ┃
┃归类在网络、工具、视觉元件这样的包中，并划分给特定的类才对。除此而外，还有很多为了和低版本的Flash兼容   ┃
┃而保留的一大堆过时的函数，比如setProperty()等。                                                         ┃
┃                                                                                                        ┃
┃    我们不是苛求前人，说他们的架构设计如何如何糟糕，应当怎样怎样，而是与之比较，明白进步之处，从而对现  ┃
┃有架构有更深的理解和领悟。可以看出，这样混乱的状况已经不能适应语言发展要求的标准，只能推翻它，重新设计  ┃
┃一个科学而优雅的架构。这就是ActionScript3诞生的原因和目标。一旦开始系统架构设计，首当其冲的就是顶级包   ┃
┃中的成员安排。                                                                                          ┃
┃    由于宣布了不与ActionScript2及1兼容，没有了历史包袱，一大堆的过时函数全部淘汰，不合理的顶级类（核心  ┃
┃类）和全局函数都重新进行了划分。一些不合理的全局函数分别放到相应的包（package）中，比如getURL()，就被   ┃
┃ActionScript3中的flash.net包的navigageToURL()替代了；setInterval()函数被放置到了flash.util包中。而不应  ┃
┃放在顶级的一些原核心类在重新调整，也被放到了其它的包中                                                  ┃
┃                                                                                                        ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛


11.2 核心类的数目和列表

核心类28个,7类)
根类:Object
语言结构:Class(类)、Function(函数)、Namespace(命名空间)、arguments(参数数组)
基本类型：int(有符整形)、Boolean(布尔)、Number(浮点)、String(字符)、uint(无符整型)
常用复杂类型：Array(数组)、Date(日期)、RegExp(正则)
XML相关类：XML()、XMLList()、Qname()
异常类：Error(异常)共11个异常类
工具类：Math(数学)

全局函数6类)
类型转换函数:Array,Boolean,int,Number,Object,String,uint,XML,XMLList
URI编码解码:decodeURI,decodeURICompnent,encodeURI,URIencodeURIComponent
URL编码解码:escape,unescape
判值函数:isFinite,isNaN,isXMLName
字符串转值函数:parseFloat,parseInt
控制台输出函数:trace




================================================
第12章 数组:Array
================================================
12.1 数组(Array)的介绍
ActionScript3中的数组(Array)是以非零整数为索引的稀疏数组(sparse array).所谓稀疏就是指数组元素可以是不同数据类型,不支持类型化数组(typed array).

12.1.1 访问数组元素
数组索引从0开始

12.1.2 数组的长度
ActionScript3的数组是可变长度数组,可以使用数组的length属性访问数组长度

1.使用length属性可以返回数组长度
2.向length属性赋值,将改变数组的长度,超出当前元素的部分会使用空值作填充
3.向超出数组length值的索引赋值时,数组会自动增加长度,中间部分会用空值作填充
4.向length属性赋值时,如果低于当前length值,则减少的数组索引将被自动删除



12.2 数组(Array)的基本操作
增、删、查、改、排序
12.2.1 查找:indexOf、lastIndexOf
查找元素，找到就返回索引位置，如果找不到，返回-1
indexOf 从左到右
lastIndexOf 从右到左
indexOf/lastIndexOf(查找元素[,查找起始位置])

查找时使用的是 === 全等于条件，不作数据类型自动转换，所以 "123"与123是不同的



12.2.2 在数组首尾新增元素：push、unshift
push,在数组尾部增加元素
unshift，在数组头部增加元素

push/unshift[元素1[,元素2,...元素n]]:uint

返回值：添加元素后数组的长度



12.2.3 删除数组首尾元素:pop、shift
pop,删除数组最后一个元素
shift，删除数组第一个元素

这两个函数均无参数

返回值：所删除的元素



12.2.4 在数组当中插入或者删除元素：灵活多变的splice
数组.splice(删除起始索引[,删除数量,插入元素1,插入元素2,...插入元素n])

1.从指定索引开始，删除指定数量的元素，并在原位置上插入新元素
数组.splice(删除起始索引,删除数量,插入元素1,插入元素2,...插入元素n)

删除起始索引可以为负数，即从结尾倒数第负数个元素开始向后删除,-1则为倒数第一个元素

2.删除指定起始点后的指定数量元素
数组.splice(删除起始索引,删除数量)

3.删除指定起始点后的所有元素
数组.splice(删除起始索引)

4.在数组某索引位后，插入元素
数组.splice(删除起始索引,0,插入元素1,插入元素2,...插入元素n)

返回值：被删除的元素

注意：splice会改变所操作的数组对象，如果只是想得到数组一段内容，请使用slice



12.2.5 获取数组中的部分元素：slice
数组.slice([获取起始索引,获取终止索引]):Array
起始和终止索引都可以使用负数

返回值：
1.查找到元素组成的新数组，数组元素包含起点索引元素，但不包括终止索引元素（即前一个）
2.只有获取起始索引时，返回从起始索引处到结尾所有元素的数组
3.不提供参数时，将生成原数组的一个浅复制

注意：当起始索引大于终止索引时，函数会函数一个空值，负数索引时特别容易出错


12.2.6 将多个元素或数组拼合成新的数组：concat
数组.slice([元素1,元素2,...元素n]):Array
与push一样，是在数组尾部追加数据
不同的是
1.push影响原始数组，concat不影响原始数组，而是返回一个新结果的数组对象
2.当追加的对象是数组时，push会直接添加，而concat会按元素顺序逐个加入到新数组中
3.不提供参数时，将生成原数组的一个浅复制

返回值：结果数组

12.2.7 数组的浅复制与深复制
浅复制就是说只是复制引用，操作对应对象时还会影响引用的对象。
一般调用数组的slice或concat函数时，不传入参数，都可以生成浅复制对象

深复制不是生成复制对象的一个副本，所有对返回对象的操作，都不会影响到原始对象，是完全复制。

深复制使用ByteArray类

var BA对象:ByteArray = new ByteArray();
BA对象.writeObject(源对象);
BA对象.position = 0;
var 备份对象:Array = BA对象.readObject() as Array;


12.2.8 排序：reverse、sort、sortOn(均会影响源数组)
数组.reverse():Array
reverse将数组倒序排序

返回值：排序后的新数组


sort([排序方式|比较函数]):Array
1.不提供参数时，将按默认的ascii排序规则排序
2.传入排序方式：排序方式其实就是Array类内置的一组常量
Array.CASEINSENSITIVE     值为1 ,大小写不敏感顺序排序，数字按从小到大
Array.DESCENDING          值为2 ,按字母倒序
Array.UNIQUESORT          值为4 ,必须唯一性排序，如果排序元素中有重复，结果将返回0(即放弃排序)
Array.RETURNINDEXEDARRAY  值为8 ,sort或sortOn函数排序后返回排序后的索引列表，保持原数组不变
Array.NUMERIC             值为16,强制sort和sortOn函数对数值采用从小到大排序，按数值排序时必须用此

排序方式可以用 | 分隔开作为一组参数传入sort或sortOn，也可以将对应值相加直接传入

3.比较函数
function 函数名(参数A:类型, 参数B:类型):int{

}

排序时，会自动匹配所有两个参数进行比较，
当返回值为1时，参数A对应元素排到参数B对应元素后
当返回值为0时，参数A与参数B位置保持不变
当返回值为-1时，参数B对应元素排到参数A对应元素前


sortOn("name"[,排序方式|比较函数]):Array
sortOn用于对复杂型数据数组进行排序

[详细请看书p211，此节笔记无法清晰记录]



12.3 操作数组每个元素:forEach、every、filter、map、some
(本节笔记略) p214





================================================
第13章 字符串：String
================================================
13.2.1 运用charAt()和charCodeAt()    取字/取字Unicode码
字符对象.charAt(索引)
获取索引指定处的字符，索引从0开始

字符对象.charCodeAt(索引)
获取索引指定处的字符的Unicode整型值。

13.2.2 运用formCharCode()             根据Unicode码返回字符
formCharCode:根据传入的数值返回对应字符
这是String类的静态属性

String.formCharCode(Unicode码[,Unicode码])
多个Unicode码可用逗号分隔
例如:
String.formCharCode(27583,22530,20043,36335O); //返回 殿堂之路 四个字
String.formCharCode(0x41,0x53,0x33); //返回 AS3 ，这里用了16进制值


13.6 常用的字符串操作
13.6.1 indexOf()的使用及search()的区别           查找字符
字符对象.indexOf(查询对象[,搜索起始索引])
如果没找到结果，则返回-1

13.6.2 substring()、slice()和substr()的使用及区别    查找并获取字符
三者的共同点都是不会影响源操作字符串
字符对象.substring(起点位置[,终点位置])
字符对象.slice(起点位置[,终点位置])
字符对象.substr(起点位置,截取长度)

substring:
1.起始点和终点不能为负数，否则会被当成0处理。
2.如果起始点索引大于终点索引，执行时索引位置会互换。
3.如果只填写起始索引，则结束索引默认为最后一个字符

slice:
1.起点索引和终点索引均支持负数索引，当索引为负时，代表从右向左数
2.如果起始点大于终止点，则返回一个空字符
3.如果只填写起始索引，则结束索引默认为最后一个字符

substr:
参数支持正数和负数。



13.6.3 split()与正则表达式结合运用
字符对象.split(分隔符|正则表达式)     拆分字符为数组
支持强大的正则表达式

13.6.4 使用XML对象实现输入不规则文本
var XML对象:XML =  
<标签>
<![CDATA[

文本

]]>
</标签>

XML对象.toString();
//通过XML对象的toString方法就可以得到完整代码了
trace(XML对象.toString())


13.7 实用的mx.utils.StringUtil工具类
import mx.utils.StringUtil

StringUtil.trim(str:String):void 去除两端空白
StringUtil.substitute(str:String,...rest):String 替换字符串
更多内容详见书本p228





================================================
第14章 强大的正则表达式：RegExp
================================================
14.2.2 正则表达式的两个构成部分
简写模式：
var 正则对象:RegExp = /匹配模式/标志位
构造函数模式：
var 正则对象:RegExp = new RegExp(匹配模式,标志位)

匹配模式就是正则表达式，标志位包括五个字母 gimsx

14.3 正则表达式语法
14.3.1 正则表达式中的文字符号
普通文字和符号：A-Z a-z 0-9 以及不是元字符的其它符号
输入Unicode字符时，同String一样，使用\uXXXX  

元字符：三三二三个一(记忆口诀)
三个括号：      {[(
三个匹配次数:   *+? 星加问
两个断言:       ^$ 定头定尾
三个一：        | 选择符 . 模糊匹配 \ 转义

三个括号：
{定义匹配次数
[字符集
(子模式

三个匹配次数:
* 匹配出现0次或多次
+ 匹配出现至少1次或多次

匹配出现0次最多1次

两个断言：
^ 在/后出现时为左端断言， /^
$ 在/前出现时为右端断言， $/

三个独立元字符：
| 选择符，匹配时兼容匹配选择符两边的字符
. 模糊匹配，可以代替

不可见字符：比较一些转义的控制字符

14.3.2 正则表达式中的字符集
1.字符集的概念和最简单的字符集形式
[字符集]

字符集用中括号括起来
Unicode字符请使用\uXXXX  四位十六进制Unicode代码输入
如：/g[eo]t,分别匹配get和got,但不会匹配geot，因为字符集只能匹配一个字符

2.连字符在字符集中的运用
[字符-字符]
如:[a-z][A-Z]，就是匹配英文字母字符集了


3.取反符号在字符集中的运用
[^字符集]
添加取反符号后，匹配时将忽略字符集中的所有元素

4.字符集中需要转义的特殊字符
\转义符号
常见要转义的字符有三类：
1.字符串: 双引号"  单引号 ' 反斜杠 \
2.正则表达式的源字符
3.字符集中的: [\^-


尽可能将会产生歧义的字符转义


14.3.3 特殊的点号(.)
.号可以替代任意单个字符，作为正则表达式中的模糊匹配字符

1.点号不匹配新行符(\n)
多行字符的模糊匹配中，.号不能匹配\n换行符，要匹配换行符，必须在标志位中使用s

2.尽量少使用点号“.”
只在明确不会模糊匹配时出错的情况下才用.模糊匹配,点号匹配所有的Unicode字符。


14.3.4 选择符
| 对选择符两边的元素作任意匹配。
使用|选择符时，尽可能使用括号将两边的操作数括起来，以方便区别。

14.3.5 括号与分组
() 圆括号将表达式的一部分括起来，就会将这部分定交成组，一旦命名了组，就可以通过“向后引用”来调用它。
它所括起的部分一般用于：
1.和选择符搭配，规定作用于选择符的范围，如/he(got|get)it/
2.和限定符搭配使用，指定匹配的重复次数，如/(get)*/


14.3.6 用正则表达式描述字符串的重复
使用{}定义匹配的重复次数，跟在要重复的表达式或字符后面
{最小出现次数[,最多出现次数]}
还有常用的三个 非显式限定符

*+? 星加问

*  出现0次或多次    等同 {0,}
+  出现1次或多次    等同 {1,}
  出现0次或最多1次 等同 {0,1}


14.3.7 注意正则表达式的贪婪性和懒惰性
使用*+?{}的时候，正则表达式总是尽可能向右搜寻尽可能多的匹配结果，如果想禁止此贪婪性，可在操作符后加上 ?，迫使程序运行时使用懒惰模式，优先使用左边匹配的第一个结果。


14.3.8 用正则表达式来定位
断言：指定匹配发生的位置
^       匹配字符串起始的位置，一般跟在起始/后，组合成 /^
$       匹配字符串结尾的位置，一般跟在结束/前，组合成$/
\b      匹配字符边界
\B      匹配非字符边界

字符边界指空格的位置，可跟在要匹配的表达式左边或右边


14.3.9 正则表达式的5个标志位。
g   global      全局匹配，尽可能匹配全部结果
i   ignoreCase  不区分大小写匹配
m   multiline   断言控制符，使用后 ^$两个断言符才能生效
s   dotall      匹配换行符标志
x   extended    令正则表达式支持空格，但编译时会自动忽略，增加可视的友好度


14.3.10 正则表达式元字符优先线
优先级顺序从高到低排列

\                       转义符
(),(?,(?=),[]         分级定义符号，字符集定义符号
*,+,?,{n},{n,},{n,m}    限定符
^,$,\位置定义           位置和顺序
|                       选择符




14.4 正则表达式与字符串的结合使用详解
14.4.1 RegExp的exec()和test()
test方法
var RegExp对象:RegExp = /正则表达式/  或  new RegExp(正则式,标志位)
var String对象:String = 字符;
RegExp对象.test(String对象)

RegExp对象.exec(正则表达式):Array
exec返回一个匹配后的数组


14.4.3 String类的replace()与正则表达式向后引用
()使用子表达式括起的表达式，可以在后边引用 ，使用\n n为索引 从1至99
/\b([a-z]+) \1\b/gi  其中的\1就是引用前面第一个([a-z])

此节部分略过 p245


14.5 常用的正则表达式
此节略 p246-p248



================================================
第15章 XML数据处理  
================================================
一大堆理论

15.4 创建XML对象
15.4.1 使用构造函数创建XML对象
var String对象:String = 字符串
var XML对象:XML = new XML(String对象);
trace(XML对象.属性)


15.4.2 直接使用XML文本创建XML对象
var XML对象:XML = 直接输入XML文本 或换行

或者使用变量的方式

var String对象:String = 字符;
var XML对象:XML =  
<{String对象}>

变量使用{}括起来，其它的与XML普通输入无异



15.5 使用运算符操作XML数据
15.5.1 使用"."与"@" 直接访问、修改、创建和删除XML对象
访问:
var XML对象:XML = XML文本;
trace(XML对象.节点名.子节点名)
trace(XML对象.节点[索引])
trace(XML对象.节点.@属性)
trace(XML对象.节点.@属性[索引])

15.5.2 使用"."与"@"直接修改XML对象
注意：如果存在多个同级元素时，不能直接使用.和@修改，因为返回结果是XMLList对象
XML对象.节点.子节点 = 值  //直接修改节点文本
XML对象.节点.@属性 = 值  //直接修改属性值


15.5.3 使用"."与"@"直接添加删除子元素和属性
注意：如果存在多个同级元素时，不能直接使用.和@修改，因为返回结果是XMLList对象
XML对象.节点.新节点名 = new XML(); //添加一个空白节点
XML对象.节点.新节点名 = 字符串;   //添加一个字符串节点
XML对象.节点.@新属性名 = 值;   //添加一个节点属性

删除节点:
delete XML对象.节点.元素[@属性]

15.5.4 简单方便地搜索XML子元素和属性
trace(XML对象.节点..子节点)  //显示所有同级子节点
trace(XML对象.节点.@*.toXMLString()); //显示所有同级节点中的所有属性值
trace(XML对象.节点.(子节点 < 1000)); //显示节点中所有节点文本大于1000的子节点元素
trace(XML对象.节点.(@属性 == 值));  //显示节点中属性等于值的节点


15.5.5 使用正则表达式或自定义函数搜索XML子元素和属性
自定义函数:
XML对象.节点.(自定义函数(子节点));
function 自定义函数(t:*):Boolean{
        t.length()
        if(t<100000) return true;
        teturn false;
        //自定义函数将根据子节点的数量执行多次
        //自定义函数返回值必须是Boolean
}


正则表达式:
XML对象.节点.(子节点.match(正则表达式));


15.6 用API实现的一些常用XML操作
本节略p264

15.7 XML的命名空间
本节略p265

15.8 XML对象与XMLlist对象
本节略p268







================================================
第16章 异常和错误的捕捉与处理
================================================
本章暂略 p269





┏━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃　第四部分：ActionScript 3 主要的 Flash Player API  ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━┛
================================================
第17章 ActionScript3目前主要的API概览
================================================
================================================
第18章 事件发送和处理
================================================
18.1 事件(Event)处理机制的产生和原理
为了减低数据交互相方的“耦合性”，ActionScript3给出了一个很好的解决方案――DOM3事件处理机制。
    DOM3事件模型定义了一套标准的生成和处理事件消息的方法，使程序中的对象可以相互交互、通信，保持自身状态和响应变化。通俗地说，数据的提供者只管发出数据对象，只要确保数据对象是flash.events.Event类（或子类）的实例即可。这种数据对象，称为事件（Event）。

数据对象的发出者，称为事件发送者（Event dispatcher）;
接受事件的对象，称为事件侦听者（Event listener）。

    DOM3事件的优点在于，事件发送者和事件接收者的依赖性大大降低。事件发送者只需要发送事件对象，事件侦听者只需要接受事件对象。事件接收者可以改变自己的外部接口，只需要确保发送的事件对象不变即可。事件侦听者也不必关心事件接收者是否变化，只需要保证自己能够正确处理接收到的事件对象即可。


18.1.1 示意图：点菜的例子
当客人进入一家饭店时，就等于告诉这家饭店的服务生，一会儿我们要点菜，你要过来服务。当点菜时，我们只要报上要点的菜，服务生自然会记下我们的要求，并吩咐厨房。

客人就是事件发送者(Event Dispatcher)
点菜就是客人发送的事件(Event)
服务生就是事件侦听者(Event Listener)

而这个事件中，包含有3条主要内容：事件的类型、事件的目标、事件的相关数据。
事件类型(Type)：点菜，服务生根据事件的不同，作出相应的操作，如果客人要求埋单，那么服务生就到柜台取帐单。
事件目标(Target)：事件发送者，如果服务生下单后就不记得是谁点的菜，就糟糕了。

事件数据(Data)：事件所包含的其它信息，比如点菜就是菜的名字，而埋单，则是没具体信息，只是让服务生到柜台取帐单。


18.1.2 DOM3事件的执行流程
DOM3事件机制包含4个步骤：
注册侦听器、发送事件、侦听事件、移除侦听器，按顺序执行的。

注册侦听器(Add Event Listener)：指定发出的事件由哪个对象接受处理，比如进入饭店时，就是注册服务员为自己点菜事件的侦听器，如果你在大街上直接发出点菜事件（大喊点菜），是没人理你的（响应事件），客人就是服务生的侦听对象。
只有在注册侦听器后，发送的事件才能被侦听器接收到，而且发送的事件类型必须与侦听器匹配，比如你叫在饭店中叫看电影，服务生就不清楚怎样响应你了。

发送事件后，侦听器才会处理事件，不可能你没叫点菜之前，服务生就已经帮你到厨房下单了。

事件处理完成后，要移除侦听器，不可能服务生在你有之前光顾的饭店的服务生都响应你的事件，去厨房点菜，这样就不行了。


18.1.3 第一个事件处理代码例子
详阅p294
自己理解总结:
事件处理主要三个主体对象
1.事件发送者

2.事件类对象
3.事件侦听者

事件发送者:要完成事件类对象的创建及初始化,再发送出事件
事件类对象:    声明好事件名常量,及事件数据存储变量,创建时调用父类构造函数
事件侦听者:要创建响应事件处理的函数,供addEventListener调用  

文档类:
构造事件发送对象
构造事件侦听对象
事件发送对象.addEventListener(事件名常量,侦听者处理函数)
事件发送对象.事件发送方法()
事件发送对象.removeEventListener(事件名常量,侦听者处理函数)


18.2 ActionScript 3事件机制的新特色
18.2.1 回顾ActionScript 1 和 ActionScript 2中的事件机制
AS1中用户最需要用 onClipEvent() on(),既方便又直接,但缺点是逻辑分散到各个舞台元件和时间轴上,管理不便.
AS2开始,增加了一些事件处理机制:
回调函数nLoad onComplete等,如常见的XML.onload事件
事件侦听器:addListener() addEventListener

AS2.0的不足:
AS2中核心类和Flash API没有内置事件,只有组件类(mx.*)才有内置事件,除了UIComponent能发送事件,其它类都不能发送事件.
AS2中，侦听器的this关键字指向混乱，常常弄错。侦听器可以用对象object也可以用函数function。
AS2中，侦听器注册方式也有两种，一种是addListener()，如Key；一种是addEventListener()，如UIComponent类。



18.2.2 ActionScript3 事件处理机制形式上的不同
注册侦听形式统一，使用事件侦听统一使用addEventListener()
侦听器统一使用function，不再允许Object当侦听器
所发送的事件对象，必须是Event或其子类的实例




18.3 事件
p298 无法做笔记

18.4 侦听器

略过~~~~~~~~~~~~


================================================
第19章 网络通信基础
================================================
19.1 ActionScript3网络通信的流程
1.构建通信请求对象(URLRequest)
2.使用通信请求对象，构建URLLoader对象，并发出数据请求
3.数据收到之后，发出完成事件，调用“读取完成“事件的侦听器处理返回的数据


标准的加载方法：
var URL路径:String = "URL地址";
var URLRequest对象:URLRequest = new URLRequest(URL路径);
var URLLoader对象:URLLoader = new URLLoader(URLRequest对象);
提交的数据放在URLRequest对象中，读取到的数据放在URLLoader对象中。

对于URL中的值对操作，要使用URLVariables类处理。
var 值串对象:URLVariables = new URLVariables("name=foo&age=28&sex=male");
var URLRequest对象:URLRequest = new URLRequest();
URLRequest对象.url = "动态网页URL";
URLRequest对象.method = URLRequestMethod.GET; //数据格式
URLRequest对象.data = 值串对象;  //将URLVariables赋给data属性


XML数据：
var XML对象:XML = XML文本
var URLRequest对象:URLRequest = new URLRequest();
URLRequest对象.url = "动态网页URL";
URLRequest对象.contentType = "text/xml";
URLRequest对象.data = XML对象.toXMLString(); //将xml转成文本赋给data属性
URLRequest对象.method = URLRequestMethod.POST;



19.1.2 发出数据请求
发出数据请求，需要按照数据请求对象携带的信息，向指定地址发出请求，这部分由URLLoader对象来完成。
var URLLoader对象:URLLoader = new URLLoader(URLRequest对象);  //定义后立刻发送数据

var URLLoader对象:URLLoader = new URLLoader();  
URLLoader对象.load(URLRequest对象); //调用URLLoader对象的load后才发送数据


如果有数据返回，数据将放在URLLoader对象的data属性中,dataFormat属性则包含返回数据类型的值
dataFormat属性支持三个常量值：
文本型(URLLoaderDataFormat.TEXT)
二进制(URLLoaderDataFormat.BINARY)
值串对(URLLoaderDataFormat.VARIABLES)

URLLoader对象有6种事件，可以让我们侦听：
load()一调用，就发出 Event.OPEN事件
加载过程中，会发出ProgressEvent.PROGRESS事件，包含下载字节数信息
加载完成，发出Event.COMPLETE
加载完成或者失败之前，会发出HTTP状态事件HTTPStatusEvent.HTTP_STATUS
加载失败，发出IOErrorEvent.IO_ERROR
发现加载内容不合安全规则，发出SecurityErrorEvent.SECURITY_ERROR


19.1.3 侦听器函数
使用标准的DOM3事件侦听器函数即可，根据URLLoader对象的事件进行侦听。



19.3 getURL()的继承人：navigateToURL()
import flash.net.*   //使用前要导入net包
navigateToURL(URLRequest对象:URLRequest[,window:String = null])
URLRequest对象 = 网址
window = 打开窗口的方法 _self _blank _parent _top

标准语法：
var URLRequest对象:URLRequest = new URLRequest(URL地址);
navigateToURL(URLRequest对象,"_blank");

或者

navigateToURL(new URLRequest(URL地址),"_blank");



19.4 提交数据的例子
单纯提供数据，可以用sendToURL()，但一般极少这样使用，而不返回数据。
public function sendToURL(request:URLRequest):void



19.5 简述安全模型
Security.sandboxType 返回当前运行所处沙箱信息
目前Flash支持4种沙箱类型
Security.REMOTE             SWF文件来自网络，并遵守基于域的沙箱规则。
Security.LOCAL_WITH_FILE    SWF文件来自本地，可以读取本地数据，但无法访问网络通信
Security.LOCAL_WITH_NETWORK SWF文件来自网络，可与网络通信，但不能读取本地数据
Security.LOCAL_TRUSTED      SWF文件是本地文件，且已经受到用户信任，此时既可与本地文件通信，也可以与网络通信。

最后一种Security.LOCAL_TRUSTED权限最高，是在Flash IDE环境下测试是所拥有的权限。


19.5.2 跨域文件：crossdomain.xml
一个放置于网站根目录的文件，用于允许被访问的域。
<?xml version="1.0"?>
<cross-domain-policy>
<allow-access-from domain="*" />
<!-- *号定义全域允许 -->
<allow-domain-from domain="*.baidu.com" />
<!--只允许百度的域名访问资源-->
</cross-domain-policy>

更多设置技巧：
http://livedocs.adobe.com/flash/9.0_cn/main/00000349.html

19.5.3
可临时在swf内部设置允许访问的域
Security.allowDomain()  授权访问域
Security.allowDomain(URL域)  
Security.allowDomain("*")  
Security.allowDomain("*.baidu.com")  




┏━━━━━━━━━━━━━━━━━━┓
┃　第五部分：ActionScript 3 视觉编程 ┃
┗━━━━━━━━━━━━━━━━━━┛
================================================
第20章 ActionScript 3 视觉编程精要
================================================
20.1 什么是显示对象
在舞台上显示的对象，在AS3中统一被称为显示对象(Display Object)
显示对象除了包含能看得见的显示对象外,也包括不能看见但却真实存在的显示对象容器(Display Object Container)


20.1.1 ActionScript3 中显示对象等级结构
舞台(Stage)
当前SWF(文档类或MainTimeline)
容器
显示对象


20.1.2 显示列表:显示对象模型
AS3中所有显示对象归使用显示列表(Display List)的方式进行管理,只有在列表中列出的对象才会在舞台上显示。
显示对象有两种：在显示列表中(on-list)和不在显示列表中(off-list)，在显示列表中的对象会被渲染，不在显示列表中的对象依然存在，不被渲染罢了。


20.2 ActionScript3中显示对象的种类
20.1 ActionScript2中的MovieClip
MovieClip是万能的，但缺点是一旦创建，就拥有了一大堆时间轴等属性，非常浪费资源，有时候只将它作为空白容器。
MovieClip的地位在AS3中减弱了很多。


20.2.2 ActionScript3显示对象种类划分：一个统一、两个层次
一个统一，AS3中所有显示对象都统一于DisplayObject类
第一大层次：是否可以接受互动事件,可以接受的,称为 可互动的显示对象(InteractiveObject);
不可以交互的,称为非互动显示对象.

可互动的显示对象(InteractiveObject):指能够接受鼠标单击、键盘敲击等人机交互事件。
位图、形状、视频等就不能接受这些事件，所以归入不可以交互类。

第二大层次：是否可以作为容器，可以容纳其它显示对象的，称为 显示对象容器(Display Object Container)



20.3 显示对象类库架构
以下很好反映了  一个统一、两个层次  这个概念

所有显示对象都是继承自父类DisplayObject这个抽象类，而父类DisplayObject则继承自EventDispatcher类，
说明所有显示对象都能发送事件。

DisplayObject、InteractiveObject、DisplayObjectContainer是显示对象架构中的三个核心对象，
它们都是不能被实例化的抽象类


视觉架构类图:
EventDispatcher(事件类)
           ┃  
           ┃  
根类 DisplayObject(抽象类,不允许实例化,只能实例化子类)
           ┃  
           ┃  
InteractiveObject(可以交互)━━━━━━   (不可以交互)  ┏　Bitmap(位图) - Shape(容器)
           ┃                                           ┣　Video(视频) - AVM1Movie(AS1.0 2.0影片)            
　　　　　 ┃                                           ┗　[StaticText(静态文本框)* - MorphShape(形状补间)*]
           ┃                                               有*的为必须在舞台上手动创建
           ┃  
           ┃  
DisplayObjectContainer(可以作为容器)  ━  (不可以作为容器) [SimpleButton(简单按钮) - TextField(文本框)]
           ┃  
           ┃  
           ┃  
Sprite(简单容器，简化版MovieClip)   ━━  Stage(舞台) - Loader(加载)
           ┃  
           ┃  
           ┣━━━━━━━━━━━━━ mx.core.FlexSprite - mx.core.UIComponent(Flex)
           ┃  
           ┃  
           ┗━━　MovieClip(影片剪辑)
                      　┃  
                      　┃  
                      　┗━　mx.flash.UIMovieClip




20.3.1 InteractiveObject类和非InteractiveObject类
InteractiveObject类    可以接受人机交互事件
非InteractiveObject类  不可以接受人机交互事件
不可以接受人机交互事件的类中有6个同级对象 ：
AVM1Movie、Bitmap、MorphShape、Shape、StaticText、Video

其中再细分  MorphShape 和 StaticText不可以用代码创建
StaticText是Flash编辑环境下用文本工具创建的
MorphShape是在flash中创建形状渐变时自动生成的

AVM1Movie： Actionscript Virtual Machine1(ActionScript虚拟机1)，即使用AS1.0 AS2.0创建的Flash影片，
为了向下兼容，当载入使用以上版本AS创建的影片时，会自动创建这个类，以同AVM2区分开来。



20.3.2 容器类和非容器类
第二层是InteractiveObject类的对象
包含三类，使用容器与非容器的概念来区分。
容器：可以在它里面加载其它的DisplayObject的容器
非容器对象：TextField、SimpleButton
TextField就是动态文本框

SimpleButton是Flash API

剩下的就是DisplayObjectContainer(显示对象容器)类，其下有：
Sprite、Loader、Stage
Stage是舞台类
Loader是原有MovieClip中加载外部资源的方法集合。

20.3.3 Sprite 和 MovieClip
Sprite将是我们在AS3中接触最多的容器，可以把它理解成去掉时间轴的MovieClip。
Sprite中含有Graphic对象，可以像MovieClip那样直接在自身绘图，但Sprite不同于Shape，
区别在于Sprite是容器，而Shape不是。

MovieClip是Sprite的子类，只保留了一些与时间轴控制相关的gotoAndStop方法和currentFrame属性等。


20.3.4 非Flash API的几个显示对象类
需要在Flex中使用到的显示对象，必须是UIComponent类的子类或实现IUIComponent的接口(Interface)



20.4 ActionScript3 视觉架构的优越性
20.4.1 更高效的渲染，更好的内存利用
AS3中影片剪辑被弱化成
绘制矢量使用轻量的Shape对象，
需要容器使用轻量的Sprite对象，
降低了时间轴的使用，也同时降低了内存的浪费。


20.4.2 自动化的深度管理
AS3中的显示对象深度由程序自动管理。
每个DisplayObjectContainer实例都有numChildren属性，用于显示对象容器中的子对象数目
显示对象容器列表中对象的索引从0开始，到numChildren-1


20.4.3 完整遍历显示列表
在AS3中，可以访问显示列表中的所有对象，包括使用ActionScript创建的对象及在IDE中绘制的对象。


20.4.4 列表外的显示对象
只有在显示列表中的对象才会被显示在舞台上，添加到显示列表的方法是调用addChild()或addChildAt()




================================================
第21章 DisplayObject类与矢量图、位图
================================================
21.1.1 显示对象的可视属性列表
AS3中所有原有对象的属性前面的下划线都去掉了，直接使用字母 ，比如 _x _y _alpha 之类变成x y alpha
注意的是：
scaleX scaleY alpha 之类原来0-100的值，在AS3中变成了0-1，其中的百分比使用小数
显示对象基本有11个可视属性(共有25个)：
x、y、width、height、scaleX、scaleY、mouseX、mouseY、rotation、alpha、visible

21.1.2 显示对象的其它属性
显示对象除了11个可视属性外，还有5个常用属性和9个不太常用的属性。
除此之外，DisplayObject还拥有6个实例方法，能发出6种事件。

5个常用属性：
name:   显示对象名字，与AS2不同的是，创建对象时，name会自动分配
parent: 父容器，指向显示列表的父容器，当显示对象不在显示列表中时，该属性为null
root:   返回当前SWF主类的实例引用。
stage:  舞台
mask:   遮罩，指向用来遮罩的对象。



21.2 所有显示对象的抽象父类：DisplayObject类
DisplayObject类是一个不能被实例化的抽象类，也不能创建直接继承DisplayObject的子类，而只能继承自DisplayObject具体子类
DisplayObject类具有7个子类，分成两类，一类是InteractiveObject抽象类，
另一类是非InteractiveObject类的六个具体类，这六个类都是直接继承自DisplayObject类，不是InteractiveObject的子类，
因此不能接受鼠标事件，也不会发出人机交互事件。

21.3 矢量图
Shape类是最简单的DisplayObject类型，与父类不同的是它多了一个graphics的实例属性，这个属性持有Graphics类对象的引用。

21.3.1 Graphics对象
Graphics对象只能由AS3内建的显示对象创建并调用，所有的矢量图形代码绘制均使用它创建。
Graphics对象并不是显示对象类，而是直接继承自根类Object。也没法用代码创建Graphics对象。
Graphics对象绘制方法分类(详细见P341 或帮助 flash.display > Graphics 相关方法 属性)

使用代码绘图时，一般遵从顺序：设置线头样式、填色、移动绘画点、画线或绘制图形、结束填色(endFill())。
设置线头样式、填色都是可选的。

只要含有Graphics的显示对象都可以绘制矢量图。
AS3中拥有Graphics对象的DisplayObject子类有3个：Shape、Sprite、MovieClip,Shape只支持纯矢量图，Sprite可以容纳矢量图与其它对象。


21.3.2 绘制矢量图的例子
var 显示对象:Shape = new Shape();
显示对象.graphics.beginFill(0xff0000);
显示对象.graphics.drawCircle(100,100,40);
显示对象.graphics.endFill();
addChild(显示对象);



21.4 位图
21.4.2 Bitmap和BitmapData
位图的所有像素信息存储在Bitmap对象的BitmapData属性持有的BitmapData对象中，
Bitmap对象不是显示对象，它直接继承自Object
BitmapData对象可以看成是一个特殊数组(二维数组)，其中存储的每个一个颜色值，是一个32位的ARGB值
A,alpha透明度， 值从0x00-0xFF ， ARGB组合的值就是  0xFF00000  共8位16进制值。

BitmapData对象记录的像素ARGB值是直接提交Flash Player渲染的，所以直接改变BitmapData中的像素信息，就可以改变舞台上的位图对象。

21.4.3 使用BitmapData 创建和改变位图
import flash.display.BitmapData;
import flash.display.Bitmap;


21.5 遮罩
21.5.1 定义普通遮罩
设置显示对象的mask属性，即可定义遮罩。
显示对象.mask = 遮罩对象;  //设置遮罩
显示对象.mask = null;  //撤消遮罩

遮罩对象不需要一定在显示列表中的对象，但如果需要实现遮罩跟随场景缩放，用户调整大小等操作，必须要在显示列表中。  


21.5.2 定义Alpha通道遮罩
要使用Alpha通道遮罩，遮罩和被遮罩的对象都需要使用位图缓存。
另外，遮罩对象需要具有Alpha透明通道渐变的信息才可以。
使用滤镜或者Graphics对象的渐变填充方法都可以创建具有Alpha透明通道渐变的信息的图形。

设置显示对象使用位图缓存：
显示对象.cacheAsBitmap = true;

21.6 文本
与文本相关的所有类在flash.text.*包中，动态文本框由TextField类实现。
创建文本框只需要 new一个TextField类的实例即可
使用type来决定文本框是属于动态还是输入，
type=TextFieldType.DYNAMIC
输入文本框
type=TextFieldType.INPUT


21.6.2 捕获HTML文本超链接的信息
HTML文本框中的超链接<a href 必须以event:开头，将超链接要发送的信息放置在它的后面。
当单击链接时，会发出一个事件，是flash.events.TextEvent类的实例，事件类型是TextEvent.LINK
<a href='event:geturl|网址|窗口方式'>链接</a>
文本框.addEventListener(TextEvent.LINK,侦听函数)


24.6.3 在文本框中追加文本请使用高效率的 appendText()
在AS3中使用appendText替代原来的+=添加字符串
文本框.appendText("追加的字串")
文本的规模越大，appendText的效率优势越明显。


21.7 碰撞检测
hitTestObject(objisplayObject):Boolean 检测是否与某个显示对象(obj)碰撞。
hitTestPoint(x:Number,y:Number,shapeFlag:Boolean=false):Boolean
检测是否和某个舞台坐标点发生碰撞，其中shapeFlag定义的是检查显示对象的实际像素(true)，
还是检查显示对象的边框(false).


21.8 自定义显示对象类
创建的自定义显示对象类,必须继承自DisplayObject的具体子类。
所谓子类，即排除DisplayObject、InteractiveObject、DisplayObjectContainer  三个抽象类，
这三个类都没提供在屏幕上渲染自身的API，因为自定义显示对象必须要继承自这三类的具体子类。
根据需求考虑继承Shape、Bitmap、Video中的某个类。在实际编程中，以继承Shape最为常见。



===========================================================
第22章 容器：DisplayObjectContainer与Sprite、MovieClip
===========================================================
显示对象容器(DisplayObjectContainer)是显示对象的子类，可以在其内放置显示对象，当然也包括容器。

22.1 容器的概念和实现
容器有属于自己的子对象列表，既包括非容器显示对象也可以包括子容器对象。

在AS3中有6个重要的容器，包括DisplayObjectContainer的4个子类：Sprite、MovieClip、Loader和Stage
也包括Flex组件架构中的mx.core.UIComponent 、 mx.flash.UIMovie


22.1.1 DisplayObjectContainer类
与DisplayObject一样，不能实例化，也不能直接子类继承，它只作为一种数据类型，要使用，则要使用到它具体的容器子对象。
DisplayObjectContainer类具有4个属性和13个实例方法：
子显示对象数目属性: numberChildren:int

添加、删除子对象的方法：  添加: addChild方法、addChildAt方法  删除: removeChild方法、removeChildAt方法

访问子对象的方法：        getChildAt 方法 、 getChildByName方法、getChildIndex方法、 getObjectsUnderPoint方法

检测子对象的方法：        contains方法 、 areInaccessibleObjectsUnderPoint方法

设置叠放次序的方法：      setChildIndex方法、 swapChildren方法、 swapChildrenAt方法

剩下三个属性： mouseChildren tabChildren textSnapshot

22.1.2 最轻量的容器：Sprite类

22.2 添加、删除视觉元件
在AS3中，创建对象和渲染对象是分开处理的，建立对象，一般只需要 new关键字加类构造函数即可。
渲染显示对象，则必须要将其加入到显示列表中，当加入的容器不在显示列表中的时候，加入的子对象也不显示。
添加、删除子对象的方法：  添加: addChild方法、addChildAt方法  删除: removeChild方法、removeChildAt方法


22.2.1 Flash程序中所有显示对象的添加流程
Flash运行过程
先创建一个Stage容器对象，当第一个SWF载入后，会自动成为Stage容器的一个子显示对象。


22.2.2 addChild方法、removeChild方法和contains方法
addChild方法：添加显示对象到列表
removeChild方法：移除显示对象
contains方法：   用于检测一个容器中是否包含指定显示对象

容器对象.addChild(显示对象);
容器对象.removeChild(显示对象);

addChild和removeChild都有返回值，返回作为目标参数的显示对象，当参数错误时，会抛出ArgumentError异常。

容器对象.contains(显示对象)
contains如果检测到传入的显示对象，则返回true，否则返回false，contains方法不仅检测当前容器所包含的子容器和子显示对象，
还检查子容器的子容器和显示对象。。。。一直到末端。最彻底的检测方法。



22.2.3 重要：添删显示对象的注意点
显示对象的状态独立于显示列表,即使从显示列表中删除显示对象，但显示对象的状态还是保持的。
显示对象的坐标座标属性相对于父容器注册点为准 。


同一个显示对象多次添加到不同容器时，只允许最后一个添加的容器拥有对象。
(同一个显示对象无论被代码加入显示列表多少次,在屏蔽上只会有一个显示对象.)


22.3 深度管理
深度由每个容器的子对象列表所管理。容器的numChildren属性显示该容器内所拥有的子显示对象数量。
子显示对象的深度同显示列表索引挂钩，从0到numChildren这个范围，连续无间断深度。
当更新显示对象深度时，子对象列表会自动更新该对象插入位后的索引。

22.3.1 深度的产生顺序和一个注重点
graphics对象不是Shape显示对象，也不在Sprite对象的子对象列表中，始终处于Sprite对象所有子对象的下面。

22.3.2 addChildAt和removeChildAt
指定添加显示对象的深度，可以用addChildAt，删除亦然。
容器对象.addChildAt(显示对象,深度);
容器对象.removeChildAt(深度);
两方法均返回显示添加和被删除的显示对象。
如果传入对象不合理，同样会触发ArgumentError异常对象。

22.3.3 交换不同深度的对象：swapChildren和swapChildrenAt
容器对象.swapChildren(显示对象A,显示对象B);
容器对象.swapChildrenAt(深度A,深度B);
两方法均不返回值。


22.3.4 重设列表中已有对象的深度：setChildIndex
容器对象.setChildIndex(显示对象,指定深度)
显示对象如果不在对象列表中，会抛出ArgumentError异常，如果指定深度超出合理范围，会抛出RangeError异常

常用方法：
置顶:
容器对象.setChildIndex(显示对象A,容器对象.numChildren-1)

置底:
容器对象.setChildIndex(显示对象A,0)

插入到显示对象B前:
容器对象.setChildIndex(显示对象A,容器对象.getChildIndex(显示对象B))

插入到显示对象B后:
容器对象.setChildIndex(显示对象A,容器对象.getChildIndex(显示对象B)-1)

使用setChildIndex后，显示对象列表会自动更新索引，不用我们操心。



22.4 访问和遍历容器子显示对象
在AS2.0中可以使用.点语法来访问对象,主要是因为MovieClip是动态类,可以动态添加子引用.
在AS3.0中， Sprite是最重要的容器，不是动态类，是密封类，因此不能使用点语法来访问。
Flash CS3创建环境下创建的MC可以用点语法访问，但在as中创建的MovieClip则不能使用点语法访问。
访问容器的子显示对象，有三种方法：通过深度访问、通过名字访问、通过全局座标访问。

22.4.2 通过深度访问子显示对象
容器对象.getChildAt(深度);
返回值为DisplayObject类型，使用DisplayObject前要对数据进行转换，getChildAt(深度) as 容器类型


22.4.3 遍历容器的子显示对象
使用递归,并判断返回的显示对象是否属于DisplayObjectContainer


22.4.4 通过name访问显示对象
容器对象.getChildByName("显示对象名字");

22.4.5 通过坐标访问显示对象
容器对象.getObjectsUnderPoint(点对象):Array

返回值是一个数组，其中包含该点下所有的显示对象~~~~~~~
如果检测到一个容器，则会继续检测其子对象。


22.5 MovieClip(影片剪辑)
AS3.0中，MovieClip的重要性被降低了，除了在创作时创建的MC具有时间轴外，用代码创建的不会拥有时间轴。
而一般用代码创建时，直接使用Sprite代替MovieClip。

22.5.1 MovieClip的播放
MovieClip在AS3中保留了AS2中所大部分属性和时间轴操作方法，基本没变。

22.5.2 为何在Flash创作工具中依然可以使用点号加影片实例名访问子影片
在AS2.0中直接使用点语法访问对象的方法在AS3.0中应当抛弃，而直接使用访问显示对象的三种标准方式来访问。

22.5.3 未公开的API：方便实用的 addFrameScript()
    影片剪辑.addFrameScript(帧数1索引,函数1,帧数2索引,函数2,帧数n索引,函数n)
    function 函数1():void{

    {
    function 函数2():void{

    {

注意帧数索引是从0开始的。




22.6 加载外部图像、SWF文件
使用Loader类对象加载外部图像、SWF文件时，加载完成后将保存在Loader对象的content实例属性中。
Loader对象加载内容时，它的属性ContentLoaderInfo属性所持有的对象会发出加载进度事件。
监听加载进度发出的ProgressEvent.PROGRESS，该事件对象中含有bytesLoader(已加载)和bytesTotal(总字节)数据.

详细参看LoadBinary加载一章内容，雷同。

22.6.1 加载SWF文件示例
加载外部图像或SWF文件:使用Loader对象的load()方法

侦听加载完成事件：侦听contentLoaderInfo对象的Event.COMPLETE事件

访问加载对象及访问其听脚本或子显示对象：
加载成功后，加载的对象可以通过Loader对象的content属性访问到。或者，也可以直接访问contentLoaderInfo.content，
这两个对象均指向加载的对象，如果要访问被加载SWF文件中的脚本或显示对象，应先把这个content转型成被加载SWF文件的主类对象，再来访问它

使用contentLoaderInfo对象的applicationDomain属性获取外部SWF文件中的所有类信息。得到类定义后，创建新的实例。


22.6.4 访问被加载SWF文件的参数及访问网页传入的参数(flashvars)
AS3中所有传入参数，都放置在加载对象的loaderInfo属性中的parameter对象
加载对象.loaderInfo.pparameter.参数名
也可以用for in遍历



===========================================================
第23章 Flash CS3：库元件的类绑定与
===========================================================
23.1 类绑定的好处、原理和第一个例子
类绑定使元件由原来只可以使用attachMovie、createEmptyMovieClip等创建实例的途径，变成可以直接使用new 类名()的类。

23.1.1 第一个类绑定的例子：自定义标签按钮